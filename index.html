<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Simple &amp; Sinister</title>
<style>
  :root{
    --bg:#0f1115; --card:#1b1f27; --muted:#a9b0bf; --line:#2a2f3b;
    --btn:#2e3442; --primary:#4c7dff; --done:#2f9e44; --warn:#f59f00;
    --radius:14px;
  }
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:#f5f5f5}
  header{padding:1rem;text-align:center;font-weight:700;letter-spacing:.3px}
  .tabs{display:flex;gap:.5rem;justify-content:center;padding:0 1rem 1rem;flex-wrap:wrap}
  .tab{background:var(--card);color:#fff;border:none;border-radius:999px;padding:.45rem .85rem;font-size:.95rem}
  .tab.active{background:var(--primary)}
  section{padding:0 1rem 1rem}
  .card{background:var(--card);border-radius:var(--radius);padding:1rem;margin-bottom:1rem;box-shadow:0 6px 18px rgba(0,0,0,.18)}
  h2{font-size:1rem;margin:0 0 .75rem 0;font-weight:700}
  .row{display:flex;justify-content:space-between;align-items:center;margin:.4rem 0;gap:.75rem;flex-wrap:wrap}
  .muted{color:var(--muted);font-size:.92rem}
  .hr{height:1px;background:var(--line);margin:.75rem 0}
  button{background:var(--btn);color:#fff;border:none;border-radius:12px;padding:.6rem .9rem;font-size:.95rem}
  button.primary{background:var(--primary)}
  button.done{background:var(--done)}
  button.warn{background:var(--warn);color:#111}
  button.ghost{background:transparent;border:1px solid var(--line)}
  .timer{font-size:2.1rem;text-align:center;margin:.4rem 0}
  .set{display:flex;justify-content:space-between;align-items:center;padding:.32rem 0}

  .set.doneRow{opacity:.55;text-decoration:line-through}
  .set input[type="checkbox"]{margin-right:.6rem}

  /* --- Cosmetic refinements (no logic changes) --- */
  .set{padding:.22rem 0}
  .set span{display:flex;align-items:center;gap:.4rem}
  .set input[type="checkbox"]{margin-right:.35rem}
  .star{font-size:.9em;opacity:.9}
  .mini{color:var(--muted);font-size:.85rem}
  .pill{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:.15rem .55rem;font-size:.82rem;color:var(--muted)}
  .progressRow{display:flex;justify-content:space-between;align-items:center;gap:.6rem;flex-wrap:wrap;margin:.25rem 0 .45rem 0}

  .star{color:#ffd43b}
  select{background:var(--btn);color:#fff;border:1px solid var(--btn);border-radius:10px;padding:.45rem .6rem;font-size:.95rem}
  input[type="checkbox"]{width:18px;height:18px}
  .historyItem{display:flex;justify-content:space-between;gap:1rem;padding:.45rem 0}
  .historyItem .left{white-space:nowrap}
  .historyItem .right{margin-left:auto;white-space:nowrap}
  footer{padding:1rem;text-align:center;font-size:.8rem;color:#777}

  /* --- Timer button UX --- */
  button.timerAction{background:var(--warn);color:#111;font-weight:700}
  .btnRow{display:flex;gap:.75rem;flex-wrap:wrap}
  .btnRow button{flex:1;min-width:140px;padding:.85rem 1rem;border-radius:14px}
  .btnRow button.ghost{flex:0 0 auto;min-width:110px;padding:.7rem .9rem;opacity:.9}
  @media (max-width:420px){
    .btnRow button{min-width:100%}
    .btnRow button.ghost{min-width:100%}
  }

</style>
</head>
<body>
<header>Simple &amp; Sinister</header>

<div class="tabs">
  <button id="tabToday" class="tab active" onclick="showTab('today')">Today</button>
  <button id="tabHistory" class="tab" onclick="showTab('history')">History</button>
  <button id="tabSettings" class="tab" onclick="showTab('settings')">Settings</button>
</div>

<section id="todayTab">
  <div class="card">
    <h2>Status</h2>
    <div id="status">Loading…</div>
    <div class="hr"></div>
    <div class="muted" id="status2"></div>
  </div>

  <div class="card" id="warmupCard">
    <h2>Warm-up</h2>
    <div id="warmupList"></div>
    <div class="hr"></div>
    <button class="primary" onclick="go(state.preSimple ? 'swingsCard' : 'skillCard')">Warm-up done</button>
    <div class="row" style="margin-top:.6rem">
      <button class="ghost" onclick="startRecoveryFromWarmup()">Dragging your tail?</button>
      <span class="mini">Recovery swings only</span>
    </div>
  </div>

  
  <div class="card" id="recoveryCard" style="display:none">
    <h2>Recovery Swings</h2>
    <div class="muted">
      Low energy day: do <b>two-hand swings</b> with an <b>active negative</b> (overspeeded eccentric).<br/>
      2–4 sets · 5–10 reps · full rest · stop before fatigue.<br/>
      <span class="mini">This does <b>not</b> count as a session and does not change progression.</span>
    </div>
    <div class="hr"></div>
    <div class="row">
      <button class="primary" onclick="finishRecovery()">Done</button>
      <button class="ghost" onclick="cancelRecovery()">Back</button>
    </div>
  </div>

<div class="card" id="skillCard" style="display:none">
    <h2>Skill</h2>
    <div id="skillLine" class="muted"></div>
    <div class="timer" id="skillTimer">5:00</div>
    <div class="row btnRow">
      <button class="timerAction" onclick="startSkill()">Start</button>
      <button class="done" onclick="finishSkill()">Finish</button>
      <button class="ghost" onclick="skipSkill()">Skip</button>
    </div>
  </div>

  <div class="card" id="swingsCard" style="display:none">
    <h2>Swings</h2>
    <div class="timer" id="swingTimer">0:00</div>
    <div class="progressRow"><span id="swingProgress" class="pill">Swings 0/10</span><span class="mini">Tap a row to check it off</span></div>
    <div id="swingSets"></div>
    <div class="hr"></div>
    <div class="row btnRow">
      <button class="timerAction" onclick="startSwings()">Start</button>
      <button class="done" onclick="finishSwings()">Finish Swings</button>
    </div>
  </div>

  <div class="card" id="restCard" style="display:none">
    <h2>Rest</h2>
    <div class="timer" id="restTimer">1:00</div>
    <div class="muted">Auto-advances after 1:00</div>
  </div>

  <div class="card" id="getupsCard" style="display:none">
    <h2>Get-Ups</h2>
    <div class="timer" id="getupTimer">0:00</div>
    <div class="progressRow"><span id="getupProgress" class="pill">Get-Ups 0/10</span><span class="mini">Tap a row to check it off</span></div>
    <div id="getupSets"></div>
    <div class="hr"></div>
    <div class="row btnRow">
      <button class="timerAction" onclick="startGetUps()">Start</button>
      <button class="done" onclick="finishGetUps()">Finish Get-Ups</button>
    </div>
  </div>

  <div class="card" id="cooldownCard" style="display:none">

    <h2>Cool-down</h2>
    <div class="timer" id="cooldownTimer">1:00</div>
    <div class="row btnRow"><button class="timerAction" onclick="startCooldown()">Start timer</button></div>
    <div id="cooldownExtras">
    <div class="row"><span>90/90 Stretch</span></div>
    <div class="row"><span>Straddle Stretch</span></div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <button id="finishSessionBtn" class="ghost">Finish Session</button>
      <button class="ghost" onclick="resetToWarmup()">Back to top</button>
    </div>
  </div>
</section>

<section id="historyTab" style="display:none">
  <div class="card">
    <h2>History</h2>
    <div class="muted">Swings time · Get-Ups time</div>
    <div class="hr"></div>
    <div id="historyList"></div>
    <div class="hr"></div>
    <div class="row" style="flex-wrap:wrap">
      <button class="ghost" onclick="exportCSV()">Export CSV</button>
      <button class="ghost" onclick="clearHistory()">Clear History</button>
    </div>
  </div>
</section>

<section id="settingsTab" style="display:none">
  <div class="card">
    <h2>Settings</h2>

    <div class="row">
      <span class="muted">Current Bell (S)</span>
      <select id="bellSelect" onchange="setBell(this.value)"></select>
    </div>

    <div class="row">
      <span class="muted">Wave Mode</span>
      <label class="row" style="gap:.5rem;justify-content:flex-end;margin:0">
        <input id="waveToggle" type="checkbox" onchange="setWaveMode(this.checked)" />
        <span class="muted">Bell jumps are +4 kg (instead of +8). S+ stays +8.</span>
      </label>
    </div>

    
    <div class="row">
      <span class="muted">Pre-Simple (On-Ramp)</span>
      <label class="row" style="gap:.5rem;justify-content:flex-end;margin:0">
        <input id="preSimpleToggle" type="checkbox" onchange="setPreSimple(this.checked)" />
        <span class="muted">Warm-up + 15 min swings + 15 min get-ups. No progression, no history.</span>
      </label>
    </div>

<div class="row">
      <span class="muted">Half Mode</span>
      <label class="row" style="gap:.5rem;justify-content:flex-end;margin:0">
        <input id="halfToggle" type="checkbox" onchange="setHalfMode(this.checked)" />
        <span class="muted">Every 2 weeks: +1 step. S+ is +4 kg.</span>
      </label>
    </div>

    <div class="hr"></div>

    <div class="row">
      <span class="muted">Skills block</span>
      <label class="row" style="gap:.5rem;justify-content:flex-end;margin:0">
        <input id="skillsToggle" type="checkbox" onchange="setSkillsEnabled(this.checked)" />
        <span class="muted">Enabled</span>
      </label>
    </div>

    
    <div id="skillModeWrap" style="display:none">
      <div class="row">
        <span class="muted">Skill selection</span>
        <select id="skillModeSelect" onchange="setSkillMode(this.value)">
          <option value="sfg1">SFG I</option>
          <option value="sfg2">SFG II</option>
          <option value="alt">Alternating SFG I / II</option>
        </select>
      </div>
      <div class="mini">Extra technique practice with light weight. Not required for Simple &amp; Sinister.</div>
    </div>
<div class="row" id="skillCycleRow">
      <span class="muted">SFG I ↔ II cycle</span>
      <select id="cycleSelect" onchange="setSfgCycleWeeks(this.value)">
        <option value="2">2 weeks</option>
        <option value="3">3 weeks</option>
        <option value="4">4 weeks</option>
      </select>
    </div>

    <div class="hr"></div>

    <div class="row">
      <span class="muted">Post-Simple sessions/week</span>
      <select id="postFreqSelect" onchange="setPostFreq(this.value)">
        <option value="4">4 (default)</option>
        <option value="3">3</option>
      </select>
    </div>

    <div class="row">
      <span class="muted">Timed day in Post-Simple</span>
      <label class="row" style="gap:.5rem;justify-content:flex-end;margin:0">
        <input id="timedToggle" type="checkbox" onchange="setTimedEnabled(this.checked)" />
        <span class="muted">Enabled</span>
      </label>
    </div>

    <div class="hr"></div>

    <div class="row">
      <span class="muted">Re-entry (full ladder)</span>
      <button id="reEntryBtn" class="warn" onclick="activateReEntry()">Start re-entry</button>
      <button id="reEntryCancelBtn" class="ghost" onclick="cancelReEntry()" style="display:none">Stop</button>
    </div>
    <div class="muted" style="font-size:.85rem;margin-top:.4rem">
      4× −16 kg, 4× −8 kg, daarna 4 sessies per Step (0 → your current step).<br/>
      Progressie pauzeert tijdelijk en hervat automatisch.
    </div>

    
    <div class="hr"></div>

    <div class="row">
      <span class="muted">Manual level-up</span>
      <button id="manualLevelBtn" class="warn" onclick="manualLevelUp()">Advance 1 step</button>
    </div>
    <div class="muted" style="font-size:.85rem;margin-top:.4rem">
      Advances exactly <b>one wave step</b> (Baseline → Step 1 → …).<br/>
      • No weight increase<br/>
      • Only available after 2 weeks<br/>
      • Cooldown resets after use
    </div>

    <div class="row">
      <span class="muted">Manual step-back</span>
      <button id="manualStepBackBtn" class="warn" onclick="manualStepBack()">Back 1 step</button>
    </div>
    <div class="muted" style="font-size:.85rem;margin-top:.4rem">
      Moves back exactly <b>one step</b> (Step 3 → 2, etc.).<br/>
      If you are at Baseline (Step 0), it returns to <b>Step 4</b> of the previous bell.
    </div>

</div>


    <div class="row">
      <button class="warn" onclick="resetProgram()">Reset program (keep history)</button>
      <button class="ghost" onclick="resetAll()">Factory reset</button>
    </div>

    <div class="hr"></div>
    <div class="muted">
      Notes: Timeless = &lt;32 kg. Post-Simple = ≥32 kg. Two-hand swings every 3rd session.
    </div>
  </div>
</section>

<footer>Simple &amp; Sinister</footer>

<script>
/* ---------- Storage ---------- */
const DEFAULT_STATE = {
  session: 0,
  S: 24,
  step: 0,
  phase: 'auto',
  waveMode: false,
  halfMode: false,
  preSimple: false,
  skillsEnabled: true,
  skillCycle: 0,
  sfgCycleWeeks: 2,
  postSessionsPerWeek: 4,
  timedEnabled: true,
  lastManualLevelUpSession: null,
  // Re-entry (full ladder) override
  reEntryActive: false,
  reEntryBaseS: null,
  reEntryBaseStep: null,
  reEntryIndex: 0,
  skillMode: 'alt' // 'sfg1' | 'sfg2' | 'alt'
};

let state = (() => {
  const raw = localStorage.getItem('ss_state');
  if(!raw) return structuredClone(DEFAULT_STATE);
  try{
    const s = JSON.parse(raw);
    return {...structuredClone(DEFAULT_STATE), ...s};
  }catch{
    return structuredClone(DEFAULT_STATE);
  }
})();

let history = (() => {
  const raw = localStorage.getItem('ss_history');
  if(!raw) return [];
  try{ return JSON.parse(raw) || []; }catch{ return []; }
})();

function saveState(){ localStorage.setItem('ss_state', JSON.stringify(state)); }
function saveHistory(){ localStorage.setItem('ss_history', JSON.stringify(history)); }

/* ---------- Per-session set checkmarks ---------- */
function progressKey(){ return `ss_progress_${state.session}`; }
function loadProgress(){
  const raw = localStorage.getItem(progressKey());
  if(!raw) return { swings: Array(10).fill(false), getups: Array(10).fill(false) };
  try{
    const p = JSON.parse(raw) || {};
    return {
      swings: Array.isArray(p.swings) ? p.swings.slice(0,10).map(Boolean).concat(Array(10).fill(false)).slice(0,10) : Array(10).fill(false),
      getups: Array.isArray(p.getups) ? p.getups.slice(0,10).map(Boolean).concat(Array(10).fill(false)).slice(0,10) : Array(10).fill(false)
    };
  }catch{
    return { swings: Array(10).fill(false), getups: Array(10).fill(false) };
  }
}
function saveProgress(p){
  localStorage.setItem(progressKey(), JSON.stringify(p));
}
let progress = loadProgress();

/* ---------- Wake Lock ---------- */
let wakeLock = null;
async function requestWakeLock(){
  try{
    if('wakeLock' in navigator){
      wakeLock = await navigator.wakeLock.request('screen');
    }
  }catch(e){ /* ignore */ }
}
async function releaseWakeLock(){
  try{
    if(wakeLock){ await wakeLock.release(); wakeLock=null; }
  }catch(e){ /* ignore */ }
}
document.addEventListener('visibilitychange', () => {
  if(document.visibilityState === 'visible' && (timerInterval || restTimeout)){
    requestWakeLock();
  } else {
    releaseWakeLock();
  }
});

/* ---------- Data ---------- */
const SFG1 = [
  {name:'Military Press', ladder:'1-2-3'},
  {name:'Double Front Squat', ladder:'1-2-3'},
  {name:'Snatch', ladder:'5-10-15'},
  {name:'Double Clean', ladder:'2-4-6'}
];
const SFG2 = [
  {name:'Push Press / Push Jerk', ladder:'2-4-6'},
  {name:'Bent Press / Windmill', ladder:'1-2-3'},
  {name:'Clean/Snatch + Reverse Lunge', ladder:'1-2-3'},
  {name:'Bottom-Up Clean–Press–Squat', ladder:'1-1-1'}
];
const BELL_OPTIONS = [8,12,16,20,24,28,32,36,40,44,48,52,56];

/* ---------- Helpers ---------- */

function getEffectiveParams(){
  // Default: no override
  const baseS = state.S;
  const baseStep = state.step;

  if(!state.reEntryActive){
    return { S: baseS, step: baseStep, label: null, stage: null, stagePos: null, total: null };
  }

  const minBell = Math.min(...BELL_OPTIONS);
  const clampBell = (x)=> Math.max(minBell, x);

  const bS = (Number.isFinite(state.reEntryBaseS) ? state.reEntryBaseS : baseS);
  const bStep = (Number.isFinite(state.reEntryBaseStep) ? state.reEntryBaseStep : baseStep);
  const idx = Math.max(0, parseInt(state.reEntryIndex,10) || 0);

  // Total sessions: 4x(-16) + 4x(-8) + 4x per step from 0..bStep
  const total = 8 + 4 * (bStep + 1);

  if(idx < 4){
    return { S: clampBell(bS - 16), step: 0, label: '−16 kg', stage: 'minus16', stagePos: `${idx+1}/4`, total };
  }
  if(idx < 8){
    return { S: clampBell(bS - 8), step: 0, label: '−8 kg', stage: 'minus8', stagePos: `${(idx-4)+1}/4`, total };
  }

  const j = idx - 8;
  const stepLevel = Math.min(bStep, Math.floor(j / 4)); // 0..bStep
  const pos = (j % 4) + 1;
  return { S: bS, step: stepLevel, label: `Step ${stepLevel}`, stage: 'step', stagePos: `${pos}/4`, total };
}

function reEntryTotalSessions(){
  const bStep = Number.isFinite(state.reEntryBaseStep) ? state.reEntryBaseStep : state.step;
  return 8 + 4 * (bStep + 1);
}

function activateReEntry(){
  const msg =
    'Start re-entry (full ladder)?\n\n' +
    'This runs (4 sessions per rung):\n' +
    '• −16 kg (4x)\n' +
    '• −8 kg (4x)\n' +
    '• Step 0 → your current step (4x each)\n\n' +
    'During re-entry, step and weight progression are paused.\n' +
    'After that, you automatically resume where you left off.';
  if(!confirm(msg)) return;

  state.reEntryActive = true;
  state.reEntryBaseS = state.S;
  state.reEntryBaseStep = state.step;
  state.reEntryIndex = 0;
  saveState();
  location.reload();
}

function cancelReEntry(){
  if(!confirm('Stop re-entry and return to your normal step?')) return;
  // Return to frozen base if available; otherwise keep current
  if(Number.isFinite(state.reEntryBaseS)) state.S = state.reEntryBaseS;
  if(Number.isFinite(state.reEntryBaseStep)) state.step = state.reEntryBaseStep;
  state.reEntryActive = false;
  state.reEntryIndex = 0;
  saveState();
  location.reload();
}


function sessionsForTwoWeeks(){
  return state.nominalSessionsPerWeek * 2;
}
function canManualLevelUp(){
  if(state.step >= 4) return false;
  const last = state.lastManualLevelUpSession;
  if(last === null) return state.session >= sessionsForTwoWeeks();
  return (state.session - last) >= sessionsForTwoWeeks();
}
function manualLevelUp(){
  if(!canManualLevelUp()) return;
  if(!confirm('Advance exactly ONE step in the current wave?\nNo weight increase. Cooldown resets.')) return;
  state.step++;
  state.lastManualLevelUpSession = state.session;
  saveState();
  location.reload();
}

function canManualStepBack(){
  if(state.step > 0) return true;
  const dec = promoteIncrement(); // 4 if wave, else 8
  const minBell = Math.min(...BELL_OPTIONS);
  return (state.S - dec) >= minBell;
}
function manualStepBack(){
  if(!canManualStepBack()) return;
  const dec = promoteIncrement();
  const msg = (state.step > 0)
    ? `Go back 1 step? (Step ${state.step} → Step ${state.step - 1})\n\nSession count stays the same.`
    : `You are at Baseline (Step 0).\nGo back to previous bell?\n\nS ${state.S} → ${state.S - dec} kg and Step 4.\nSession count stays the same.`;
  if(!confirm(msg)) return;

  if(state.step > 0){
    state.step--;
  } else {
    state.S = state.S - dec;
    state.step = 4;
  }
  saveState();
  location.reload();
}


function sPlusOffset(){ return state.halfMode ? 4 : 8; }
function Splus(){ return getEffectiveParams().S + sPlusOffset(); }
function fmt(sec){
  sec = Math.max(0, Math.floor(sec));
  return `${Math.floor(sec/60)}:${String(sec%60).padStart(2,'0')}`;
}
function parseMMSS(txt){
  const parts = String(txt).trim().split(':');
  if(parts.length!==2) return 0;
  const m = parseInt(parts[0],10) || 0;
  const s = parseInt(parts[1],10) || 0;
  return m*60+s;
}

/* ---------- Phase logic ---------- */
function computePhase(){
  const eff = getEffectiveParams();

  state.currentPhase = (state.phase === 'auto')
    ? (eff.S >= 32 ? 'post' : 'timeless')
    : state.phase;

  state.nominalSessionsPerWeek = (state.currentPhase === 'post')
    ? (parseInt(state.postSessionsPerWeek,10) || 4)
    : 6;

  state.isTimedDay = (state.currentPhase === 'post' && state.timedEnabled)
    ? ((state.session % state.nominalSessionsPerWeek) === (state.nominalSessionsPerWeek - 1))
    : false;
}

function sessionsPerStep(){
  // Default: 4 weeks per step (classic S&S)
  // Half Mode: 2 weeks per step
  return state.nominalSessionsPerWeek * (state.halfMode ? 2 : 4);
}

/* ---------- SFG cycle ---------- */
function sessionsPerSfgCycle(){
  const w = Math.max(2, Math.min(4, parseInt(state.sfgCycleWeeks,10) || 2));
  return w * state.nominalSessionsPerWeek;
}
function activeSfgSet(){
  const cycleLen = sessionsPerSfgCycle();
  const block = Math.floor(state.session / cycleLen);
  return (block % 2 === 0) ? 'I' : 'II';
}
function skillsStatusLabel(){
  if(!state.skillsEnabled) return 'Skills OFF';
  const mode = state.skillMode || 'alt';
  if(mode === 'sfg1') return 'SFG I';
  if(mode === 'sfg2') return 'SFG II';
  return `SFG ${activeSfgSet()}`; // alternating shows active set (I/II)
}

function currentSkill(){
  const mode = state.skillMode || 'alt';

  let skills = SFG1;
  if(mode === 'sfg2') skills = SFG2;
  else if(mode === 'alt'){
    const set = activeSfgSet();
    skills = (set === 'I') ? SFG1 : SFG2;
  }

  return skills[state.skillCycle % skills.length];
}

/* ---------- Step loading mapping ---------- */
function isSwingStar(setNum){
  const effStep = getEffectiveParams().step;
  if(effStep === 0) return false; // Baseline
  const max = 2 * effStep + 2; // step1->4, step2->6, step3->8, step4->10
  return (setNum >= 3 && setNum <= Math.min(10, max));
}
function isGetUpPairStar(pairIndex){
  // 5 pairs, match swing expansion conceptually
  // baseline: none
  // step1: pairs 3-4
  // step2: pairs 3-5
  // step3: pairs 2-5
  // step4: all
  const effStep = getEffectiveParams().step;
  if(effStep === 0) return false;
  if(effStep === 1) return (pairIndex === 3 || pairIndex === 4);
  if(effStep === 2) return (pairIndex >= 3);
  if(effStep === 3) return (pairIndex >= 2);
  if(effStep === 4) return true;
  return false;
}

/* ---------- UI rendering ---------- */

function toggleSwingDone(idx, on){
  progress.swings[idx] = !!on;
  saveProgress(progress);
  renderSwings();
}
function rowToggle(kind, idx, ev){
  // Make entire row tappable without changing training logic
  if(ev && ev.target && ev.target.tagName && ev.target.tagName.toLowerCase() === 'input') return;
  if(kind === 'swing'){
    toggleSwingDone(idx, !progress.swings[idx]);
  }else{
    toggleGetUpDone(idx, !progress.getups[idx]);
  }
}

function toggleGetUpDone(idx, on){
  progress.getups[idx] = !!on;
  saveProgress(progress);
  renderGetUps();
}
function showTab(tab){
  document.getElementById('todayTab').style.display = tab==='today' ? 'block' : 'none';
  document.getElementById('historyTab').style.display = tab==='history' ? 'block' : 'none';
  document.getElementById('settingsTab').style.display = tab==='settings' ? 'block' : 'none';
  document.getElementById('tabToday').classList.toggle('active', tab==='today');
  document.getElementById('tabHistory').classList.toggle('active', tab==='history');
  document.getElementById('tabSettings').classList.toggle('active', tab==='settings');
}

function renderStatus(){
  computePhase();
  const phaseName = state.currentPhase === 'post' ? 'Post-Simple' : 'Timeless';
  const swingType = (((state.session + 1) % 3) === 0) ? 'Two-hand swings' : 'One-arm swings';
  const timed = state.isTimedDay ? 'Timed day' : '';
  const wave = state.preSimple ? 'Pre-Simple' : (state.waveMode ? 'Wave Mode' : (state.halfMode ? 'Half Mode' : ''));
  const sfg = skillsStatusLabel();
  const re = getEffectiveParams();
  const reEntryTag = state.reEntryActive ? `Re-entry ${re.label} (${re.stagePos})` : '';

  const eff = getEffectiveParams();

  document.getElementById('status').innerText =
    `Session ${state.session + 1} · ${phaseName} · S ${eff.S} kg`;

  document.getElementById('status2').innerText =
    [`${(getEffectiveParams().step===0)?'Baseline':'Step '+getEffectiveParams().step+'/4'}`, swingType, timed, sfg, reEntryTag, wave].filter(Boolean).join(' · ');

  return;
}

function renderWarmup(){
  const list = document.getElementById('warmupList');
  list.innerHTML = '';
  if(state.currentPhase === 'post'){
    ['Prying Goblet Squat','Arm Bar (L)','Goblet Squat @ S','Arm Bar (R)','Goblet Squat @ S']
      .forEach(x => list.innerHTML += `<div class="row"><span>${x}</span></div>`);
  } else {
    ['3 rounds: 5 Prying Goblet Squat · 5+5 Halo · 5 Hip Bridge']
      .forEach(x => list.innerHTML += `<div class="row"><span>${x}</span></div>`);
  }
}

function renderSkill(){
  const el = document.getElementById('skillLine');
  if(state.preSimple){
    el.innerText = 'Pre-Simple: no skills block';
    return;
  }
  if(!state.skillsEnabled){
    el.innerText = 'Skills disabled';
    return;
  }
  const sk = currentSkill();
  el.innerText = `${sk.name}  ·  ${sk.ladder}  ·  use S- weight`;
}



function renderSwings(){
  const eff = getEffectiveParams();
  const div = document.getElementById('swingSets');
  div.innerHTML = '';

  // Pre-Simple: 15 minutes quality practice, no checkboxes
  if(state.preSimple){
    const p = document.getElementById('swingProgress');
    if(p) p.style.display = 'none';
    div.innerHTML = `<div class="muted">15 minutes of <b>quality swings</b>. Stop the set when speed or crispness drops. Rest as needed.</div>`;
    return;
  }

  const sp = Splus();
  let doneCount = 0;

  for(let i=1;i<=10;i++){
    const star = isSwingStar(i);
    const w = star ? sp : eff.S;
    const idx = i-1;
    const done = !!progress.swings[idx];
    if(done) doneCount++;

    div.innerHTML += `
      <label class="set ${done ? 'doneRow' : ''}" onclick="rowToggle('swing', ${idx}, event)">
        <span>
          <input type="checkbox" ${done ? 'checked' : ''} onchange="toggleSwingDone(${idx}, this.checked)" onclick="event.stopPropagation()" />
          Set ${i}
        </span>
        <span>${w} kg ${star ? '<span class="star">★</span>' : ''}</span>
      </label>`;
  }

  const p = document.getElementById('swingProgress');
  if(p){ p.style.display='inline-block'; p.textContent = `Swings ${doneCount}/10`; }
}





function renderGetUps(){
  const eff = getEffectiveParams();
  const div = document.getElementById('getupSets');
  div.innerHTML = '';

  // Pre-Simple: 15 minutes quality practice, no checkboxes
  if(state.preSimple){
    const p = document.getElementById('getupProgress');
    if(p) p.style.display = 'none';
    div.innerHTML = `<div class="muted">15 minutes of <b>quality get-ups</b>. Move smoothly, own every position. Rest as needed.</div>`;
    return;
  }

  const sp = Splus();
  let doneCount = 0;

  // 10 singles total: L1,R1,...,L5,R5
  for(let i=1;i<=5;i++){
    const star = isGetUpPairStar(i);
    const w = star ? sp : eff.S;

    const leftIdx = (i-1)*2;
    const rightIdx = (i-1)*2 + 1;

    const leftDone = !!progress.getups[leftIdx];
    const rightDone = !!progress.getups[rightIdx];
    if(leftDone) doneCount++;
    if(rightDone) doneCount++;

    div.innerHTML += `
      <label class="set ${leftDone ? 'doneRow' : ''}" onclick="rowToggle('getup', ${leftIdx}, event)">
        <span>
          <input type="checkbox" ${leftDone ? 'checked' : ''} onchange="toggleGetUpDone(${leftIdx}, this.checked)" onclick="event.stopPropagation()" />
          L${i}
        </span>
        <span>${w} kg ${star ? '<span class="star">★</span>' : ''}</span>
      </label>`;

    div.innerHTML += `
      <label class="set ${rightDone ? 'doneRow' : ''}" onclick="rowToggle('getup', ${rightIdx}, event)">
        <span>
          <input type="checkbox" ${rightDone ? 'checked' : ''} onchange="toggleGetUpDone(${rightIdx}, this.checked)" onclick="event.stopPropagation()" />
          R${i}
        </span>
        <span>${w} kg ${star ? '<span class="star">★</span>' : ''}</span>
      </label>`;
  }

  const p = document.getElementById('getupProgress');
  if(p){ p.style.display='inline-block'; p.textContent = `Get-Ups ${doneCount}/10`; }
}



function renderHistory(){
  const list = document.getElementById('historyList');
  list.innerHTML = '';
  if(history.length === 0){
    list.innerHTML = '<div class="muted">No entries yet.</div>';
    return;
  }
  for(const e of history){
    const swings = fmt(e.swings || 0);
    const getups = fmt(e.getups || 0);
    const left = `${e.date} · #${e.session}`;
    const right = `Swings ${swings} · Get-Ups ${getups}`;
    list.innerHTML += `<div class="historyItem"><div class="left">${left}</div><div class="right">${right}</div></div>`;
  }
}

function renderSettings(){
  // Bells
  const bellSel = document.getElementById('bellSelect');
  bellSel.innerHTML = '';
  for(const b of BELL_OPTIONS){
    const opt = document.createElement('option');
    opt.value = String(b);
    opt.textContent = `${b} kg`;
    bellSel.appendChild(opt);
  }
  if(!BELL_OPTIONS.includes(state.S)) state.S = 24;
  bellSel.value = String(state.S);

  // Toggles/selects
  document.getElementById('waveToggle').checked = !!state.waveMode;
  const halfT = document.getElementById('halfToggle');
  if(halfT) halfT.checked = !!state.halfMode;
  const preT = document.getElementById('preSimpleToggle');
  if(preT) preT.checked = !!state.preSimple;
  document.getElementById('skillsToggle').checked = !!state.skillsEnabled;

  const modeWrap = document.getElementById('skillModeWrap');
  const modeSel = document.getElementById('skillModeSelect');
  const cycleRow = document.getElementById('skillCycleRow');
  const cycleSel = document.getElementById('cycleSelect');

  if(modeWrap && modeSel && cycleRow && cycleSel){
    modeWrap.style.display = state.skillsEnabled ? 'block' : 'none';
    modeSel.value = state.skillMode || 'alt';
    // Only show cycle selector when Alternating is chosen
    cycleRow.style.display = (state.skillsEnabled && (modeSel.value === 'alt')) ? 'flex' : 'none';
    cycleSel.value = String(state.sfgCycleWeeks || 2);
  }

  const postSel = document.getElementById('postFreqSelect');
  postSel.value = String(state.postSessionsPerWeek || 4);

  document.getElementById('timedToggle').checked = !!state.timedEnabled;

  const btn = document.getElementById('manualLevelBtn');
  if(btn){
    const ok = canManualLevelUp();
    btn.disabled = !ok;
    btn.classList.toggle('primary', ok);
    btn.classList.toggle('ghost', !ok);
    btn.style.opacity = ok ? '1' : '.55';
  }

  const backBtn = document.getElementById('manualStepBackBtn');
  if(backBtn){
    const okBack = canManualStepBack();
    backBtn.disabled = !okBack;
    backBtn.classList.toggle('primary', okBack);
    backBtn.classList.toggle('ghost', !okBack);
    backBtn.style.opacity = okBack ? '1' : '.55';
  }


  // Re-entry buttons
  const reBtn = document.getElementById('reEntryBtn');
  const reStop = document.getElementById('reEntryCancelBtn');
  if(reBtn && reStop){
    const active = !!state.reEntryActive;
    reBtn.style.display = active ? 'none' : 'inline-block';
    reStop.style.display = active ? 'inline-block' : 'none';
  }
}

/* ---------- Navigation between blocks ---------- */
function hideAllBlocks(){
  ['warmupCard','recoveryCard','skillCard','swingsCard','restCard','getupsCard','cooldownCard'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.style.display = 'none';
  });
}
function go(id){
  hideAllBlocks();
  // skillCard can be skipped automatically if disabled
  if(id === 'skillCard' && (!state.skillsEnabled || state.preSimple)){
    id = 'swingsCard';
  }
  document.getElementById(id).style.display = 'block';
  // Pre-Simple: hide cooldown extras (optional)
  const ex = document.getElementById('cooldownExtras');
  if(ex) ex.style.display = (state.preSimple && id==='cooldownCard') ? 'none' : 'block';
  configureTimersForDay();
}


/* ================== REALTIME PERSISTENT TIMERS ================== */
const TIMER_KEY = "ss_timers_v1";

function loadTimers(){
  try{ return JSON.parse(localStorage.getItem(TIMER_KEY) || "{}"); }
  catch{ return {}; }
}
function saveTimers(t){ localStorage.setItem(TIMER_KEY, JSON.stringify(t)); }
function setTimer(name, data){
  const t = loadTimers(); t[name] = data; saveTimers(t);
}
function getTimer(name){
  const t = loadTimers(); return t[name] || null;
}
function clearTimer(name){
  const t = loadTimers(); delete t[name]; saveTimers(t);
}

function clearAllRuntimeTimers(){
  ['skillTimer','swingTimer','restTimer','getupTimer'].forEach(clearTimer);
  localStorage.removeItem(TIMER_KEY); // extra zekerheid
}

function realtimeCountdown(name, elementId, seconds, onDone){
  requestWakeLock();
  const endAt = Date.now() + seconds*1000;
  setTimer(name, {type:"down", endAt, elementId, done:false});

  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    const t = getTimer(name);
    if(!t) return;
    const remaining = Math.max(0, Math.ceil((t.endAt - Date.now())/1000));
    document.getElementById(elementId).innerText = fmt(remaining);
    if(remaining <= 0 && !t.done){
      t.done = true; setTimer(name, t);
      clearInterval(timerInterval); timerInterval = null;
      beep();
      onDone && onDone();
    }
  },200);
}

function realtimeCountUp(name, elementId){
  requestWakeLock();
  const startAt = Date.now();
  setTimer(name, {type:"up", startAt, elementId});

  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    const t = getTimer(name);
    if(!t) return;
    const elapsed = Math.floor((Date.now()-t.startAt)/1000);
    document.getElementById(elementId).innerText = fmt(elapsed);
  },200);
}

function restoreTimer(name){
  const t = getTimer(name);
  if(!t) return;
  if(t.type === "down"){
    realtimeCountdown(name, t.elementId, Math.max(0, Math.ceil((t.endAt-Date.now())/1000)));
  }
  if(t.type === "up"){
    realtimeCountUp(name, t.elementId);
  }
}
/* =============================================================== */

/* ---------- Timers ---------- */
let timerInterval = null;
let restTimeout = null;
let swingSeconds = null;
let getupSeconds = null;

function stopTimer(){
  if(timerInterval){ clearInterval(timerInterval); timerInterval = null; }
}

function startCountdown(elementId, totalSeconds){ realtimeCountdown(elementId, elementId, totalSeconds); return; }
function __old_startCountdown(elementId, totalSeconds){
  stopTimer();
  requestWakeLock();
  let remaining = totalSeconds;
  document.getElementById(elementId).innerText = fmt(remaining);
  timerInterval = setInterval(()=>{
    remaining--;
    document.getElementById(elementId).innerText = fmt(remaining);
    if(remaining <= 0){
      stopTimer();
    }
  }, 1000);
}

function startCountUp(elementId){ realtimeCountUp(elementId, elementId); return; }
function __old_startCountUp(elementId){
  stopTimer();
  requestWakeLock();
  let t = 0;
  document.getElementById(elementId).innerText = fmt(t);
  timerInterval = setInterval(()=>{
    t++;
    document.getElementById(elementId).innerText = fmt(t);
  }, 1000);
}

function configureTimersForDay(){
  // Only set defaults; do not override actively running timers
  if(state.preSimple){
    if(!timerInterval && document.getElementById('swingsCard').style.display !== 'none'){
      document.getElementById('swingTimer').innerText = '15:00';
    }
    if(!timerInterval && document.getElementById('getupsCard').style.display !== 'none'){
      document.getElementById('getupTimer').innerText = '15:00';
    }
    return;
  }
  if(state.isTimedDay){
    if(!timerInterval && document.getElementById('swingsCard').style.display !== 'none'){
      document.getElementById('swingTimer').innerText = '5:00';
    }
    if(!timerInterval && document.getElementById('getupsCard').style.display !== 'none'){
      document.getElementById('getupTimer').innerText = '10:00';
    }
  } else {
    if(!timerInterval && document.getElementById('swingsCard').style.display !== 'none'){
      document.getElementById('swingTimer').innerText = '0:00';
    }
    if(!timerInterval && document.getElementById('getupsCard').style.display !== 'none'){
      document.getElementById('getupTimer').innerText = '0:00';
    }
  }
}

/* Skill timer */
function startSkill(){ startCountdown('skillTimer', 300); }
function finishSkill(){ stopTimer(); releaseWakeLock(); go('swingsCard'); }
function skipSkill(){ stopTimer(); releaseWakeLock(); go('swingsCard'); }

/* ---------- Recovery (Dragging your tail) ---------- */
function startRecoveryFromWarmup(){
  // Decide after moving a bit (warm-up). No session/progression changes.
  stopTimer(); releaseWakeLock();
  if(restTimeout){ clearTimeout(restTimeout); restTimeout = null; }
  hideAllBlocks();
  document.getElementById('recoveryCard').style.display = 'block';
}
function cancelRecovery(){
  hideAllBlocks();
  document.getElementById('warmupCard').style.display = 'block';
}
function finishRecovery(){
  // Intentionally does NOT log history and does NOT advance session/step.
  stopTimer(); releaseWakeLock();
  if(restTimeout){ clearTimeout(restTimeout); restTimeout = null; }
  hideAllBlocks();
  document.getElementById('warmupCard').style.display = 'block';
}


/* Swings timer */
function startSwings(){
  if(state.preSimple){ startCountdown('swingTimer', 900); return; }
  if(state.isTimedDay) startCountdown('swingTimer', 300);
  else startCountUp('swingTimer');
}
function finishSwings(){
  if(state.preSimple){
    stopTimer();
    releaseWakeLock();
    go('getupsCard');
    return;
  }
  if(state.isTimedDay){
    const remaining = parseMMSS(document.getElementById('swingTimer').innerText);
    swingSeconds = 300 - remaining;
  } else {
    swingSeconds = parseMMSS(document.getElementById('swingTimer').innerText);
  }
  stopTimer();

  if(state.isTimedDay){
    go('restCard');
    document.getElementById('restTimer').innerText = '1:00';
    startCountdown('restTimer', 60);
    if(restTimeout) clearTimeout(restTimeout);
    restTimeout = setTimeout(()=>{
      restTimeout = null;
      go('getupsCard');
    }, 60000);
  } else {
    releaseWakeLock();
    go('getupsCard');
  }
}

/* Get-ups timer */
function startGetUps(){
  if(state.preSimple){ startCountdown('getupTimer', 900); return; }
  if(state.isTimedDay) startCountdown('getupTimer', 600);
  else startCountUp('getupTimer');
}
function finishGetUps(){
  if(state.preSimple){
    stopTimer();
    releaseWakeLock();
    go('cooldownCard');
    return;
  }
  if(state.isTimedDay){
    const remaining = parseMMSS(document.getElementById('getupTimer').innerText);
    getupSeconds = 600 - remaining;
  } else {
    getupSeconds = parseMMSS(document.getElementById('getupTimer').innerText);
  }
  stopTimer();
  releaseWakeLock();
  go('cooldownCard');
}

/* ---------- Progression / session finish ---------- */
let __finishGuard = false;

function promoteIncrement(){
  // Wave Mode: smaller bell jumps (+4) but still uses classic S+ offset (+8)
  // Half Mode: faster steps (every 2 weeks) and smaller S+ offset (+4)
  if(state.halfMode) return 4;
  if(state.waveMode) return 4;
  return 8;
}


function finishSessionOrPractice(){
  if(__finishGuard) return;
  __finishGuard = true;
  setTimeout(()=>{ __finishGuard = false; }, 400);
  if(state.preSimple){
    // Practice only: no history, no progression
    if(!confirm('Finish practice session?')) return;
    stopTimer(); releaseWakeLock();
    if(restTimeout){ clearTimeout(restTimeout); restTimeout = null; }
    swingSeconds = null; getupSeconds = null;
    hideAllBlocks();
    document.getElementById('warmupCard').style.display = 'block';
    return;
  }
  return finishSession();
}

function finishSession(){
  if(!confirm('Finish session? This cannot be undone.')) return;
  // HARD RESET current & next session checkmarks (start clean)
  const oldSession = state.session;
  localStorage.removeItem(`ss_progress_${oldSession}`);
  localStorage.removeItem(`ss_progress_${oldSession + 1}`);
  // Save history entry (times only)
  const now = new Date();
  history.unshift({
    date: now.toISOString().slice(0,10),
    session: state.session + 1,
    swings: (typeof swingSeconds === 'number') ? swingSeconds : 0,
    getups: (typeof getupSeconds === 'number') ? getupSeconds : 0
  });
  saveHistory();

  // Advance session (always)
  state.session++;
  // Load fresh checkmarks for the new session
  progress = loadProgress();

  // Re-entry: pause step/weight progression, only advance the re-entry ladder
  if(state.reEntryActive){
    state.reEntryIndex = (parseInt(state.reEntryIndex,10) || 0) + 1;

    const total = reEntryTotalSessions();
    if(state.reEntryIndex >= total){
      // Resume exactly where you were when you started re-entry
      if(Number.isFinite(state.reEntryBaseS)) state.S = state.reEntryBaseS;
      if(Number.isFinite(state.reEntryBaseStep)) state.step = state.reEntryBaseStep;
      state.reEntryActive = false;
      state.reEntryIndex = 0;
    }
  } else {
    const stepLen = sessionsPerStep();
    if(state.session % stepLen === 0){
      state.step++;
      if(state.step > 4){
        state.step = 0;
        state.S += promoteIncrement();
      }
    }
  }

  // Skill rotation always advances per session (even if skipped)
  state.skillCycle++;

  // Reset transient timers for next session
  swingSeconds = null; getupSeconds = null;
  stopTimer(); releaseWakeLock();
  if(restTimeout){ clearTimeout(restTimeout); restTimeout = null; }

  saveState();
  location.reload();
}

function resetToWarmup(){
  stopTimer(); releaseWakeLock();
  if(restTimeout){ clearTimeout(restTimeout); restTimeout=null; }
  swingSeconds = null; getupSeconds = null;
  hideAllBlocks();
  document.getElementById('warmupCard').style.display = 'block';
}

/* ---------- Settings actions ---------- */
function setBell(val){
  const n = parseInt(val,10);
  if(!Number.isFinite(n)) return;
  state.S = n;
  saveState();
  location.reload();
}
function setWaveMode(on){
  state.waveMode = !!on;
  if(state.waveMode) state.halfMode = false; // mutually exclusive
  saveState();
  renderSettings();
  renderStatus();
}
function setHalfMode(on){
  state.halfMode = !!on;
  if(state.halfMode) state.waveMode = false; // mutually exclusive
  saveState();
  location.reload();
}

function setPreSimple(on){
  state.preSimple = !!on;
  if(state.preSimple){
    // Pre-Simple is practice only. Keep it simple: disable skills during practice.
    state.skillsEnabled = false;
  }
  saveState();
  location.reload();
}

function setSkillMode(val){
  const v = String(val);
  if(v !== 'sfg1' && v !== 'sfg2' && v !== 'alt') return;
  state.skillMode = v;
  saveState();
  renderStatus();
  renderSkill();
  renderSettings();
}

function setSkillsEnabled(on){
  state.skillsEnabled = !!on;
  saveState();
  renderStatus();
  renderSkill();
  renderSettings();
}
function setSfgCycleWeeks(val){
  state.sfgCycleWeeks = parseInt(val,10) || 2;
  saveState();
  renderStatus();
  renderSkill();
}
function setPostFreq(val){
  state.postSessionsPerWeek = parseInt(val,10) || 4;
  saveState();
  location.reload();
}
function setTimedEnabled(on){
  state.timedEnabled = !!on;
  saveState();
  location.reload();
}

function clearAllProgressKeys(){
  const keys = [];
  for(let i=0;i<localStorage.length;i++){
    const k = localStorage.key(i);
    if(k && k.startsWith('ss_progress_')) keys.push(k);
  }
  keys.forEach(k=>localStorage.removeItem(k));
}

function resetProgram(){
  const ok = confirm('Reset session, step and skill cycle? (History stays)');
  if(!ok) return;
  clearAllProgressKeys();
  const keep = { S: state.S, wave: state.waveMode, skillsEnabled: state.skillsEnabled, sfgCycleWeeks: state.sfgCycleWeeks, postSessionsPerWeek: state.postSessionsPerWeek, timedEnabled: state.timedEnabled };
  state = {...structuredClone(DEFAULT_STATE), ...keep};
  saveState();
  location.reload();
}

function resetAll(){
  const ok = confirm('Factory reset EVERYTHING including history?');
  if(!ok) return;
  clearAllProgressKeys();
  localStorage.removeItem('ss_state');
  localStorage.removeItem('ss_history');
  location.reload();
}

/* ---------- History actions ---------- */
function exportCSV(){
  if(history.length === 0){ alert('No history to export.'); return; }
  const header = ['date','session','swings_seconds','getups_seconds'];
  const rows = history.map(e => [e.date,e.session,e.swings||0,e.getups||0]);
  const csv = [header.join(','), ...rows.map(r=>r.join(','))].join('\\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'simple_and_sinister_history.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
function clearHistory(){
  const ok = confirm('Clear all history entries?');
  if(!ok) return;
  history = [];
  saveHistory();
  renderHistory();
}

/* ---------- Boot ---------- */
function init(){
  computePhase();
  renderStatus();
  renderWarmup();
  renderSkill();
  renderSwings();
  renderGetUps();
  renderHistory();
  renderSettings();

  // Start on warmup
  hideAllBlocks();
  document.getElementById('warmupCard').style.display = 'block';
  configureTimersForDay();


  // Mobile reliability: ensure Finish Session responds to touch
  const fsb = document.getElementById('finishSessionBtn');
  if(fsb){
    const handler = (ev)=>{
      try{ ev.preventDefault && ev.preventDefault(); ev.stopPropagation && ev.stopPropagation(); }catch(e){}
      // Call directly so embedded WebViews treat it as a user gesture
      finishSessionOrPractice();
      return false;
    };
    fsb.addEventListener('touchend', handler, {passive:false});
    fsb.addEventListener('click', handler);
  }
}

init();

/* Cooldown timer (1:00 with beep) */
let cooldownInterval = null;
function beep(){
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = 880;
    o.connect(g); g.connect(ctx.destination);
    o.start();
    g.gain.setValueAtTime(0.2, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.25);
    o.stop(ctx.currentTime + 0.25);
  }catch(e){}
}
function startCooldown(){
  if(cooldownInterval){ clearInterval(cooldownInterval); }
  let remaining = 60;
  document.getElementById('cooldownTimer').innerText = '1:00';
  cooldownInterval = setInterval(()=>{
    remaining--;
    document.getElementById('cooldownTimer').innerText = `${Math.floor(remaining/60)}:${String(remaining%60).padStart(2,'0')}`;
    if(remaining <= 0){
      clearInterval(cooldownInterval);
      cooldownInterval = null;
      beep();
    }
  },1000);
}

</script>
</body>
</html>
